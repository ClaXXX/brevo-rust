/*
 * Brevo API
 *
 * Brevo provide a RESTFul API that can be used with any languages. With this API, you will be able to :   - Manage your campaigns and get the statistics   - Manage your contacts   - Send transactional Emails and SMS   - and much more...  You can download our wrappers at https://github.com/orgs/brevo  **Possible responses**   | Code | Message |   | :-------------: | ------------- |   | 200  | OK. Successful Request  |   | 201  | OK. Successful Creation |   | 202  | OK. Request accepted |   | 204  | OK. Successful Update/Deletion  |   | 400  | Error. Bad Request  |   | 401  | Error. Authentication Needed  |   | 402  | Error. Not enough credit, plan upgrade needed  |   | 403  | Error. Permission denied  |   | 404  | Error. Object does not exist |   | 405  | Error. Method not allowed  |   | 406  | Error. Not Acceptable  |   | 422  | Error. Unprocessable Entity |
 *
 * The version of the OpenAPI document: 3.0.0
 * Contact: contact@brevo.com
 * Generated by: https://openapi-generator.tech
 */

use crate::models;
use serde::{Deserialize, Serialize};

#[derive(Clone, Default, Debug, PartialEq, Serialize, Deserialize)]
pub struct MainPeriodReward {
    /// Maximum number of times a consumer can be attributed this reward
    #[serde(
        rename = "attributionPerConsumer",
        skip_serializing_if = "Option::is_none"
    )]
    pub attribution_per_consumer: Option<i32>,
    /// Unique identifier for the balance definition
    #[serde(
        rename = "balanceDefinitionId",
        skip_serializing_if = "Option::is_none"
    )]
    pub balance_definition_id: Option<uuid::Uuid>,
    /// Unique code for the reward
    #[serde(rename = "code", skip_serializing_if = "Option::is_none")]
    pub code: Option<String>,
    /// Total number of codes generated
    #[serde(rename = "codeCount", skip_serializing_if = "Option::is_none")]
    pub code_count: Option<i64>,
    /// Unique identifier for the code generator
    #[serde(rename = "codeGeneratorId", skip_serializing_if = "Option::is_none")]
    pub code_generator_id: Option<uuid::Uuid>,
    /// Unique identifier for the code pool
    #[serde(rename = "codePoolId", skip_serializing_if = "Option::is_none")]
    pub code_pool_id: Option<uuid::Uuid>,
    /// Configuration settings for the reward
    #[serde(rename = "config", skip_serializing_if = "Option::is_none")]
    pub config: Option<String>,
    /// Timestamp when the reward was created
    #[serde(rename = "createdAt", skip_serializing_if = "Option::is_none")]
    pub created_at: Option<String>,
    /// Disabled date of the reward
    #[serde(rename = "disabledAt", skip_serializing_if = "Option::is_none")]
    pub disabled_at: Option<String>,
    /// End date of the reward validity
    #[serde(rename = "endDate", skip_serializing_if = "Option::is_none")]
    pub end_date: Option<String>,
    /// Expiration date of the reward
    #[serde(rename = "expirationDate", skip_serializing_if = "Option::is_none")]
    pub expiration_date: Option<String>,
    /// Select startOfPeriod to configure rewards expiry on start of day/week/month/year. Select endOfPeriod to configure reward expiry on end of day/week/month/year, else select noModification
    #[serde(rename = "expirationModifier", skip_serializing_if = "Option::is_none")]
    pub expiration_modifier: Option<ExpirationModifier>,
    /// Unit of time for the rewards's availability (e.g., day/week/month/year).
    #[serde(rename = "expirationUnit", skip_serializing_if = "Option::is_none")]
    pub expiration_unit: Option<String>,
    /// Number of days/weeks/month/year for reward expiry
    #[serde(rename = "expirationValue", skip_serializing_if = "Option::is_none")]
    pub expiration_value: Option<i32>,
    /// object
    #[serde(rename = "generator", skip_serializing_if = "Option::is_none")]
    pub generator: Option<Box<models::MainPeriodGenerator>>,
    /// Unique identifier for the reward
    #[serde(rename = "id", skip_serializing_if = "Option::is_none")]
    pub id: Option<uuid::Uuid>,
    /// Attribution / Redeem Limits for the reward
    #[serde(rename = "limits", skip_serializing_if = "Option::is_none")]
    pub limits: Option<Vec<models::MainPeriodLimit>>,
    /// Id of the loyalty program to which the current reward belongs to
    #[serde(rename = "loyaltyProgramId", skip_serializing_if = "Option::is_none")]
    pub loyalty_program_id: Option<uuid::Uuid>,
    /// Additional data for reward definition
    #[serde(rename = "meta", skip_serializing_if = "Option::is_none")]
    pub meta: Option<std::collections::HashMap<String, serde_json::Value>>,
    /// Name of the reward
    #[serde(rename = "name", skip_serializing_if = "Option::is_none")]
    pub name: Option<String>,
    /// Selected products for reward definition
    #[serde(rename = "products", skip_serializing_if = "Option::is_none")]
    pub products: Option<Vec<models::MainPeriodProduct>>,
    /// Public description for the reward
    #[serde(rename = "publicDescription", skip_serializing_if = "Option::is_none")]
    pub public_description: Option<String>,
    /// Public Image for the reward
    #[serde(rename = "publicImage", skip_serializing_if = "Option::is_none")]
    pub public_image: Option<String>,
    /// Public name for the reward
    #[serde(rename = "publicName", skip_serializing_if = "Option::is_none")]
    pub public_name: Option<String>,
    /// Defines the redeem limit for the consumer
    #[serde(rename = "redeemPerConsumer", skip_serializing_if = "Option::is_none")]
    pub redeem_per_consumer: Option<i32>,
    /// Rules defined to redeem a reward
    #[serde(rename = "redeemRules", skip_serializing_if = "Option::is_none")]
    pub redeem_rules: Option<Vec<String>>,
    /// object
    #[serde(rename = "rewardConfigs", skip_serializing_if = "Option::is_none")]
    pub reward_configs: Option<Box<models::MainPeriodRewardConfigurations>>,
    /// Rule to define the reward
    #[serde(rename = "rule", skip_serializing_if = "Option::is_none")]
    pub rule: Option<Box<models::MainPeriodRule>>,
    /// Start date of attribution of the reward
    #[serde(rename = "startDate", skip_serializing_if = "Option::is_none")]
    pub start_date: Option<String>,
    /// Id of the selected balance while redeeming / attributing a reward
    #[serde(
        rename = "subtractBalanceDefinitionId",
        skip_serializing_if = "Option::is_none"
    )]
    pub subtract_balance_definition_id: Option<String>,
    /// Strategy of the Balance while redeeming / attributing a reward
    #[serde(
        rename = "subtractBalanceStrategy",
        skip_serializing_if = "Option::is_none"
    )]
    pub subtract_balance_strategy: Option<String>,
    /// Amount of balance to be selected while redeeming / attributing a reward
    #[serde(
        rename = "subtractBalanceValue",
        skip_serializing_if = "Option::is_none"
    )]
    pub subtract_balance_value: Option<i32>,
    /// Value to indicate to subtract full balance or not
    #[serde(
        rename = "subtractTotalBalance",
        skip_serializing_if = "Option::is_none"
    )]
    pub subtract_total_balance: Option<bool>,
    /// Defines the limit to which a consumer can attribute a reward
    #[serde(rename = "totalAttribution", skip_serializing_if = "Option::is_none")]
    pub total_attribution: Option<i32>,
    /// Defines the limit to which a consumer can redeem a reward
    #[serde(rename = "totalRedeem", skip_serializing_if = "Option::is_none")]
    pub total_redeem: Option<i32>,
    /// Id of the Rule to be updated for that reward
    #[serde(rename = "triggerId", skip_serializing_if = "Option::is_none")]
    pub trigger_id: Option<String>,
    /// Selected unit of the balance
    #[serde(rename = "unit", skip_serializing_if = "Option::is_none")]
    pub unit: Option<String>,
    /// Timestamp for when this reward was last updated.
    #[serde(rename = "updatedAt", skip_serializing_if = "Option::is_none")]
    pub updated_at: Option<String>,
    /// Value of metric in selected config for reward definition
    #[serde(rename = "value", skip_serializing_if = "Option::is_none")]
    pub value: Option<f64>,
    /// Type of config selected for reward definition
    #[serde(rename = "valueType", skip_serializing_if = "Option::is_none")]
    pub value_type: Option<String>,
}

impl MainPeriodReward {
    pub fn new() -> MainPeriodReward {
        MainPeriodReward {
            attribution_per_consumer: None,
            balance_definition_id: None,
            code: None,
            code_count: None,
            code_generator_id: None,
            code_pool_id: None,
            config: None,
            created_at: None,
            disabled_at: None,
            end_date: None,
            expiration_date: None,
            expiration_modifier: None,
            expiration_unit: None,
            expiration_value: None,
            generator: None,
            id: None,
            limits: None,
            loyalty_program_id: None,
            meta: None,
            name: None,
            products: None,
            public_description: None,
            public_image: None,
            public_name: None,
            redeem_per_consumer: None,
            redeem_rules: None,
            reward_configs: None,
            rule: None,
            start_date: None,
            subtract_balance_definition_id: None,
            subtract_balance_strategy: None,
            subtract_balance_value: None,
            subtract_total_balance: None,
            total_attribution: None,
            total_redeem: None,
            trigger_id: None,
            unit: None,
            updated_at: None,
            value: None,
            value_type: None,
        }
    }
}
/// Select startOfPeriod to configure rewards expiry on start of day/week/month/year. Select endOfPeriod to configure reward expiry on end of day/week/month/year, else select noModification
#[derive(Clone, Copy, Debug, Eq, PartialEq, Ord, PartialOrd, Hash, Serialize, Deserialize)]
pub enum ExpirationModifier {
    #[serde(rename = "startOfPeriod")]
    StartOfPeriod,
    #[serde(rename = "endOfPeriod")]
    EndOfPeriod,
    #[serde(rename = "noModification")]
    NoModification,
}

impl Default for ExpirationModifier {
    fn default() -> ExpirationModifier {
        Self::StartOfPeriod
    }
}
